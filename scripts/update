#!/usr/bin/env python3
# Notion 更新脚本：分阶段执行并支持异步通知/失败重试。

from __future__ import annotations

import argparse
import os
import sys
from functools import partial
from typing import List, Optional

REPO = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
SRC = os.path.join(REPO, "src")
if SRC not in sys.path:
    sys.path.insert(0, SRC)

from _pipeline import NotificationDispatcher, StepRecord, format_failure_markdown, run_step  # type: ignore
from core.config import load_config  # type: ignore
from services.notifications import format_update_markdown, send_wecom_markdown  # type: ignore
from services.sync import run_update, run_update_all, run_update_from_notion  # type: ignore


def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(
        prog="update",
        description="Quick Notion update wrapper (staged pipeline).",
    )
    p.add_argument("-e", "--execute", action="store_true", help="实际写入 Notion（默认 dry-run）")
    p.add_argument("-A", "--all", action="store_true", help="更新全部（仅更新已存在页面），默认模式")
    p.add_argument("-N", "--from-notion", action="store_true", help="从 Notion 现有页面出发（安全，仅更新）")
    p.add_argument("-l", "--limit", type=int, default=None, help="--from-notion 时最多条数")

    p.add_argument("-i", "--ids", default="", help="以逗号分隔的 TAPD 需求 ID 列表")
    p.add_argument("-I", "--id", action="append", default=[], help="重复传多个 -I 指定单个 ID")
    p.add_argument("-f", "--file", default=None, help="从文件读取需求 ID（每行一个）")
    p.add_argument("-C", "--create-missing", action="store_true", help="当页面不存在时创建（仅对 -i/-I/-f 生效）")

    p.add_argument("-o", "--owner", default=os.getenv("DEFAULT_OWNER", "江林"), help="负责人筛选（update-all 时生效）")
    p.add_argument("-c", "--creator", default=None, help="创建人筛选（update-all 时生效）")
    p.add_argument("-t", "--current-iteration", action="store_true", help="仅当前迭代（默认开启）")
    return p.parse_args()


def collect_story_ids(args: argparse.Namespace) -> List[str]:
    ids: List[str] = []
    if args.ids:
        ids.extend([s.strip() for s in str(args.ids).split(",") if s.strip()])
    if args.id:
        ids.extend([str(x).strip() for x in args.id if str(x).strip()])
    if args.file:
        try:
            with open(args.file, "r", encoding="utf-8") as f:
                for line in f:
                    s = line.strip()
                    if s:
                        ids.append(s)
        except Exception as exc:
            print(f"[update] 读取文件失败: {exc}")
    dedup: List[str] = []
    for sid in ids:
        if sid and sid not in dedup:
            dedup.append(sid)
    return dedup


def main() -> None:
    args = parse_args()
    cfg = load_config()

    has_id_inputs = bool(args.ids or args.id or args.file)
    mode = "ids" if has_id_inputs else ("from-notion" if args.from_notion else "all")

    owner = args.owner or os.getenv("DEFAULT_OWNER", "江林")
    current_iter = args.current_iteration or True  # 默认开启当前迭代

    sender = None
    if args.execute and cfg.wecom_webhook_url:
        sender = partial(send_wecom_markdown, cfg.wecom_webhook_url)
    dispatcher = NotificationDispatcher(sender)
    records: List[StepRecord] = []
    exit_code = 0

    try:
        if mode == "ids":
            ids = collect_story_ids(args)
            if not ids:
                print("[update] 未提供任何需求 ID；请使用 -i/-I/-f")
                exit_code = 2
            else:
                _, record = run_step(
                    "update-by-ids",
                    lambda: run_update(  # noqa: E731
                        cfg,
                        ids,
                        dry_run=(not args.execute),
                        create_missing=bool(args.create_missing),
                    ),
                )
                records.append(record)
                if not record.success:
                    exit_code = 1
                    if args.execute:
                        dispatcher.enqueue(format_failure_markdown(record.name, record.message))
        elif mode == "from-notion":
            _, record = run_step(
                "update-from-notion",
                lambda: run_update_from_notion(  # noqa: E731
                    cfg,
                    dry_run=(not args.execute),
                    limit=args.limit,
                ),
            )
            records.append(record)
            if not record.success:
                exit_code = 1
                if args.execute:
                    dispatcher.enqueue(format_failure_markdown(record.name, record.message))
        else:
            update_result, record = run_step(
                "update-all",
                lambda: run_update_all(  # noqa: E731
                    cfg,
                    dry_run=(not args.execute),
                    owner=owner,
                    creator=args.creator,
                    current_iteration=bool(current_iter),
                ),
            )
            records.append(record)
            if record.success:
                if args.execute:
                    dispatcher.enqueue(
                        format_update_markdown(
                            update_result,  # type: ignore[arg-type]
                            owner=owner,
                            creator=args.creator,
                            current_iteration=bool(current_iter),
                        )
                    )
            else:
                exit_code = 1
                if args.execute:
                    dispatcher.enqueue(format_failure_markdown(record.name, record.message))
    except KeyboardInterrupt:
        print("[update] 用户中断，正在清理…")
        exit_code = 130
    finally:
        dispatcher.close()
        print("[update] === 执行摘要 ===")
        if records:
            for rec in records:
                status = "OK" if rec.success else "FAIL"
                detail = f" :: {rec.message}" if rec.message else ""
                print(f"[update] {rec.name:<18} {status:<5} {rec.duration:>6.2f}s{detail}")
        else:
            print("[update] 尚未执行任何步骤。")

    sys.exit(exit_code)


if __name__ == "__main__":
    main()
