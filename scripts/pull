#!/usr/bin/env python3
# TAPD→Notion 集成脚本：拆分管线、异步通知与失败重试。

from __future__ import annotations

import argparse
import os
import sys
from functools import partial
from typing import List

# Ensure src/ is importable when running from scripts/
REPO = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
SRC = os.path.join(REPO, "src")
if SRC not in sys.path:
    sys.path.insert(0, SRC)

from _pipeline import (  # type: ignore
    NotificationDispatcher,
    StepRecord,
    format_failure_markdown,
    run_step,
)
from config import load_config  # type: ignore
from notifications import (  # type: ignore
    format_sync_markdown,
    format_update_markdown,
    send_wecom_markdown,
)
from sync import run_sync, run_sync_by_modules, run_update_all  # type: ignore


def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(
        prog="pull",
        description="Quick TAPD→Notion sync wrapper (staged pipeline).",
    )
    p.add_argument("-e", "--execute", action="store_true", help="实际写入 Notion（默认 dry-run）")
    p.add_argument("-f", "--full", action="store_true", help="全量初始化（忽略 since 边界）")
    p.add_argument("-s", "--since", default="last", help="增量边界，默认 last，可传 ISO 时间戳")
    p.add_argument("-o", "--owner", default=os.getenv("DEFAULT_OWNER", "江林"), help="负责人筛选，默认 江林（可逗号分隔）")
    p.add_argument("-c", "--creator", default=None, help="创建人筛选（显示名）")
    p.add_argument("-i", "--current-iteration", action="store_true", help="仅同步当前迭代（建议开启）")
    p.add_argument("-m", "--by-modules", action="store_true", help="按模块分组拉取（兼容多租户过滤键）")
    p.add_argument("-w", "--wipe-first", action="store_true", help="写入前清空 Notion 数据库（危险）")
    p.add_argument("-n", "--insert-only", action="store_true", help="仅新增（已存在的不更新）")
    p.add_argument("-U", "--update-after", action="store_true", help="写入成功后，按相同范围执行一次 update-all")
    p.add_argument("-P", "--no-post-update", action="store_true", help="禁止自动跟进更新（覆盖 -U 或默认行为）")
    p.add_argument(
        "--story-ids",
        default=None,
        help="按 TAPD 需求 ID 列表拉取，逗号分隔；提供该参数时忽略负责人筛选",
    )
    return p.parse_args()


def main() -> None:
    args = parse_args()
    cfg = load_config()

    owner = args.owner or os.getenv("DEFAULT_OWNER", "江林")
    current_iter = args.current_iteration or True  # 默认开启当前迭代

    since_value = None if args.full else str(args.since or "last")
    story_ids: List[str] = []
    if args.story_ids:
        story_ids = [s.strip() for s in str(args.story_ids).split(",") if s.strip()]
    if story_ids and args.by_modules:
        print("[pull] --story-ids 与 --by-modules 不兼容；请取消模块拉取或移除指定 ID")
        sys.exit(2)
    owner_filter = owner if not story_ids else None

    sender = partial(send_wecom_markdown, cfg.wecom_webhook_url) if cfg.wecom_webhook_url else None
    dispatcher = NotificationDispatcher(sender)
    records: List[StepRecord] = []
    exit_code = 0

    try:
        if args.by_modules:
            sync_callable = lambda: run_sync_by_modules(  # noqa: E731
                cfg,
                full=bool(args.full),
                since=since_value,
                dry_run=(not args.execute),
                owner=owner_filter,
                creator=args.creator,
                wipe_first=bool(args.wipe_first),
                insert_only=bool(args.insert_only),
                current_iteration=bool(current_iter),
            )
            sync_label = "sync-by-modules"
        else:
            sync_callable = lambda: run_sync(  # noqa: E731
                cfg,
                full=bool(args.full),
                since=since_value,
                dry_run=(not args.execute),
                owner=owner_filter,
                creator=args.creator,
                wipe_first=bool(args.wipe_first),
                insert_only=bool(args.insert_only),
                current_iteration=bool(current_iter),
                story_ids=story_ids,
            )
            sync_label = "sync"

        sync_result, sync_record = run_step(sync_label, sync_callable)
        records.append(sync_record)
        if sync_record.success and args.execute:
            dispatcher.enqueue(
                format_sync_markdown(
                    sync_result,  # type: ignore[arg-type]
                    owner=owner_filter,
                    creator=args.creator,
                    current_iteration=bool(current_iter),
                    since=since_value,
                    full=bool(args.full),
                    by_modules=bool(args.by_modules),
                )
            )
        elif not sync_record.success:
            exit_code = 1
            if args.execute:
                dispatcher.enqueue(format_failure_markdown(sync_record.name, sync_record.message))

        do_follow_up = (
            sync_record.success
            and (bool(args.update_after) or (args.execute and not args.no_post_update))
        )

        if do_follow_up:
            update_callable = lambda: run_update_all(  # noqa: E731
                cfg,
                dry_run=(not args.execute),
                owner=owner,
                creator=args.creator,
                current_iteration=bool(current_iter),
            )
            update_result, upd_record = run_step("update-all", update_callable)
            records.append(upd_record)
            if upd_record.success and args.execute:
                dispatcher.enqueue(
                    format_update_markdown(
                        update_result,  # type: ignore[arg-type]
                        owner=owner,
                        creator=args.creator,
                        current_iteration=bool(current_iter),
                    )
                )
            elif not upd_record.success:
                exit_code = 1
                if args.execute:
                    dispatcher.enqueue(format_failure_markdown(upd_record.name, upd_record.message))

    except KeyboardInterrupt:
        print("[pull] 用户中断，正在清理…")
        exit_code = 130
    finally:
        dispatcher.close()
        print("[pull] === 执行摘要 ===")
        if records:
            for rec in records:
                status = "OK" if rec.success else "FAIL"
                detail = f" :: {rec.message}" if rec.message else ""
                print(f"[pull] {rec.name:<14} {status:<5} {rec.duration:>6.2f}s{detail}")
        else:
            print("[pull] 尚未执行任何步骤。")

    sys.exit(exit_code)


if __name__ == "__main__":
    main()
